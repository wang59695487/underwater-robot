#include "LineCircleDetect.hpp"

// this work in new machine



//////////////////////////////////////////////////////LinePointFinder

LinePointFinder::LinePointFinder() :colorMode(0), lineWidth(20), pointNum(50) {}



void LinePointFinder::setDectParams(int colorInput, int widthInput, int numInput, int segThreshold)//ÉèÖÃÒª¼ì²âµÄÑÕÉ«ÀàÐÍ£¬Ïß¿í×îÐ¡Öµ£¬×îÉÙµãÊýµÈ²ÎÊý



{



	colorMode = colorInput;



	lineWidth = widthInput;



	pointNum = numInput;



	thresholdValue = segThreshold;


}



void LinePointFinder::segmentProcess(Mat &src, Mat &dst) //¸ù¾Ý²ÊÉ«¿Õ¼äÄ£ÐÍÊµÏÖÍ¼ÏñµÄ·Ö¸î

{

	int i = 0;

	int j = 0;

	int temp_r = 0;

	int temp_g = 0;

	int temp_b = 0;

	int temp = 0;



	for (int i = 0; i < src.rows; i++)

		for (int j = 0; j < src.cols; j++)

		{

			temp_r = (int)src.at<Vec3b>(i, j)[2];

			temp_g = (int)src.at<Vec3b>(i, j)[1];

			temp_b = (int)src.at<Vec3b>(i, j)[0];



			if (RED == colorMode) //red color

			{

				temp = temp_r * 2 - temp_g - temp_b;

			}

			else if (GREEN == colorMode) //green color

			{

				temp = temp_g * 2 - temp_r - temp_b;

			}

			else if (BLUE == colorMode) //blue color

			{

				temp = temp_b * 2 - temp_r - temp_g;

			}

			else //red color

			{

				temp = temp_r * 2 - temp_g - temp_b;

			}



			if (temp <= thresholdValue)

			{

				temp = 0;

			}

			else if (temp > thresholdValue)

			{

				temp = 255;

			}

			dst.at<uchar>(i, j) = temp;



		}



}



void LinePointFinder::segmentProcess2(Mat &src, Mat &dst)  //segment base on HSV model

{

	Mat imgHSV;

	int hValueMin, hValueMax, sValueMin, sValueMax, vValueMin, vValueMax;



	switch (colorMode)

	{

	case RED:

		hValueMin = 156;

		hValueMax = 180;

		sValueMin = 43;

		sValueMax = 255;

		vValueMin = 46;

		vValueMax = 255;

		break;

	case GREEN:

		hValueMin = 30;

		hValueMax = 90;

		sValueMin = 43;

		sValueMax = 255;

		vValueMin = 46;

		vValueMax = 255;

		break;

	case BLUE:

		hValueMin = 91;

		hValueMax = 130;

		sValueMin = 43;

		sValueMax = 255;

		vValueMin = 46;

		vValueMax = 255;

		break;

	default:

		hValueMin = 156;

		hValueMax = 180;

		sValueMin = 43;

		sValueMax = 255;

		vValueMin = 46;

		vValueMax = 255;

		break;

	}



	cvtColor(src, imgHSV, CV_BGR2HSV);

	if (RED == colorMode || 0 == colorMode || 4 == colorMode)

	{

		Mat dst1, dst2;

		inRange(imgHSV, Scalar(hValueMin, sValueMin, vValueMin), Scalar(hValueMax, sValueMax, vValueMax), dst1);

		inRange(imgHSV, Scalar(0, sValueMin, vValueMin), Scalar(25, sValueMax, vValueMax), dst2);

		dst = dst1 + dst2;

	}

	else

	{

		inRange(imgHSV, Scalar(hValueMin, sValueMin, vValueMin), Scalar(hValueMax, sValueMax, vValueMax), dst);

	}

}





int LinePointFinder::calculatePoint(Mat &src, Point &begin, Point &end) //¶Ô·Ö¸îÍ¼Ïñ½øÐÐÐÎÌ¬Ñ§´¦Àí£¬ÄâºÏµÃµ½Ö±Ïß£¬¸ù¾ÝÏß¶Î³¤¶È¶ÔÖ±Ïß½øÐÐ½Ø¶ÏµÃµ½Ïß¶ÎÁ½¶Ëµã

{

	vector<Point> findPoints;

	vector<Point> pointsX;

	vector<Point> pointsY;



	int i = 0;

	int j = 0;

	int k = 0;

	int xLeft;

	int xRight;

	int yUp;

	int yDowm;

	Point pointX;

	Point pointY;

	//cout<<"checkpoint8"<<endl;

	Mat element = getStructuringElement(MORPH_RECT, Size(5, 5));

	

	morphologyEx(src, src, MORPH_OPEN, element);

	vector<vector<Point>> lineContours;

	vector<Vec4i> hierarchy;

	Mat mask;

	mask = Mat::zeros(src.size(), CV_8UC1);

	//cout<<"checkpoint9"<<endl;

	findContours(src, lineContours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE);

	//cout<<"checkpoint10"<<endl;

	float areaContour = 0;
	float maxArea = 0;
	int index = 0;
	for (int i = 0; i < lineContours.size(); i++)

	{

		areaContour = contourArea(lineContours[i]);

		if (areaContour > maxArea)

		{

			maxArea = areaContour;

			index = i;

		}

	}

	if (maxArea == 0)

	{

		cout << "No line find!!!" << endl;

		return -1;

	}



	Rect rectContour = boundingRect(lineContours[index]);

	mask(rectContour).setTo(255);

	Mat imageMask;

	src.copyTo(imageMask, mask);

	src = imageMask.clone();









	//ÑØX·½ÏòÉ¨Ãè

	for (i = 0; i < src.rows; i++)

	{

		xLeft = 0;

		xRight = src.cols - 1;

		for (j = 0; j < src.cols - lineWidth && j >= 0; j++)

		{

			if (src.at<uchar>(i, j) == 255)

			{

				xLeft = j;

				break;

			}

		}

		for (j = src.cols - 1; j >= lineWidth && j < src.cols; j--)

		{

			if (src.at<uchar>(i, j) == 255)

			{

				xRight = j;

				break;

			}

		}

		if (xRight >= xLeft + lineWidth && xRight <= xLeft + 7 * lineWidth)

		{

			pointX.x = (xLeft + xRight) / 2;

			pointX.y = i;

			pointsX.push_back(pointX);

		}



	}



	//ÑØY·½ÏòÉ¨Ãè

	for (i = 0; i < src.cols; i++)

	{

		yUp = 0;

		yDowm = src.rows - 1;

		for (j = 0; j < src.rows - lineWidth && j >= 0; j++)

		{

			if (src.at<uchar>(j, i) == 255)

			{

				yUp = j;

				break;

			}

		}

		for (j = src.rows - 1; j >= lineWidth && j < src.rows; j--)

		{

			if (src.at<uchar>(j, i) == 255)

			{

				yDowm = j;

				break;

			}

		}

		if (yDowm >= yUp + lineWidth && yDowm <= yUp + 7 * lineWidth)

		{

			pointY.x = i;

			pointY.y = (yUp + yDowm) / 2;

			pointsY.push_back(pointY);

		}



	}



	if (pointsX.size() < pointNum && pointsY.size() < pointNum)

	{

		cout << "No line find!!!" << endl;

		return -1;

	}

	Vec4f line_detect;



	if (pointsX.size() >= pointsY.size())

		findPoints = pointsX;

	else

		findPoints = pointsY;



	int  len = findPoints.size();



	fitLine(findPoints, line_detect, CV_DIST_L2, 0, 0.01, 0.01);



	for (i = 0; i < len - 1; i++)

		line(src, findPoints[i], findPoints[i + 1], Scalar(128, 0, 0));



	int x0 = line_detect[2];

	int y0 = line_detect[3];



	int pointDisX = findPoints[len - 1].x - findPoints[0].x;

	int pointDisY = findPoints[len - 1].y - findPoints[0].y;



	int pointDis = pow((pointDisX*pointDisX + pointDisY * pointDisY), 0.5);



	pointBegin.x = x0 + pointDis / 2 * line_detect[0];

	pointBegin.y = y0 + pointDis / 2 * line_detect[1];



	pointEnd.x = x0 - pointDis / 2 * line_detect[0];

	pointEnd.y = y0 - pointDis / 2 * line_detect[1];



	if (pointBegin.y > pointEnd.y)

	{

		begin.x = pointBegin.x;

		begin.y = pointBegin.y;



		end.x = pointEnd.x;

		end.y = pointEnd.y;

	}

	else if (pointBegin.y < pointEnd.y)

	{

		begin.x = pointEnd.x;

		begin.y = pointEnd.y;



		end.x = pointBegin.x;

		end.y = pointBegin.y;



	}

	else

	{

		if (pointBegin.x <= pointEnd.x)

		{

			begin.x = pointBegin.x;

			begin.y = pointBegin.y;



			end.x = pointEnd.x;

			end.y = pointEnd.y;

		}

		else

		{

			begin.x = pointEnd.x;

			begin.y = pointEnd.y;



			end.x = pointBegin.x;

			end.y = pointBegin.y;

		}

	}



	return 0;

}


void LinePointFinder::drawDetectedLines(cv::Mat& image, cv::Scalar color = cv::Scalar(255, 0, 0)) //ÔÚÍ¼ÏñÖÐ»®³ö¼ì²âµ½µÄÖ±Ïß
{
	cv::line(image, pointBegin, pointEnd, color);
}



void LinePointFinder::calculateResult(Mat &src, Point pointA, Point pointB) //¼ÆËãÍ¼ÏñÖÐÐÄµ½¼ì²âµ½µÄÖ±ÏßµÄ¾àÀëºÍÖ±Ïß·½Ïò½Ç£¬Ö±Ïß·½ÏòÎª pointA->pointB

{

	int width = src.cols;

	int height = src.rows;



	Point center;

	center.x = cvRound(width / 2);

	center.y = cvRound(height / 2);



	int A = 0, B = 0, C = 0;

	A = pointA.y - pointB.y;

	B = pointB.x - pointA.x;

	C = pointA.x*pointB.y - pointA.y*pointB.x;



	distanceResult = -((float)(A*center.x + B * center.y + C)) / ((float)sqrtf(A*A + B * B));



	float temp = (float)(pointA.y - pointB.y) / (float)sqrtf((pointB.x - pointA.x)*(pointB.x - pointA.x) + (pointB.y - pointA.y)*(pointB.y - pointA.y));



	if (pointB.x >= pointA.x)

		angleResult = acosf(temp) * 180 / PI;

	else

		angleResult = -acosf(temp) * 180 / PI;



}

/////////////////////////////////////////////////////////////////////





/////////////////////////////////////////////////////////////////////CircleFinder

CircleFinder::CircleFinder() {}



void CircleFinder::setParams(int colorInput, int minDistValue, int minRadiusValue, int maxRadiusValue, int circleLikeValue, int segThreshold) //ÃÃ¨ÃÃÃÃ®ÃÂ¡ÃÂ²ÃÃÅ¸Ã Â£Â¬ÃÃ®ÃÂ¡ÃÂ²Â°Ã«Å¸Â¶Â£Â¬ÃÃ®Å½Ã³ÃÂ²Â°Ã«Å¸Â¶Â£Â¬Â·ÂºÂ»Â¯Â¶ÃÂµÃÂ²ÃÃÃ½

{

	colorMode = colorInput;

	minDist = minDistValue;

	minRadius = minRadiusValue;

	maxRadius = maxRadiusValue;

	circleLike = circleLikeValue;

	thresholdValue = segThreshold;

}



void CircleFinder::segmentProcess(Mat &src, Mat &dst) //¸ù¾Ý²ÊÉ«¿Õ¼äÄ£ÐÍÊµÏÖÍ¼ÏñµÄ·Ö¸î

{

	int i = 0;

	int j = 0;

	int temp_r = 0;

	int temp_g = 0;

	int temp_b = 0;

	int temp = 0;



	for (int i = 0; i < src.rows; i++)

		for (int j = 0; j < src.cols; j++)

		{



			temp_r = (int)src.at<Vec3b>(i, j)[2];

			temp_g = (int)src.at<Vec3b>(i, j)[1];

			temp_b = (int)src.at<Vec3b>(i, j)[0];



			if (RED == colorMode) //red color

			{

				temp = temp_r * 2 - temp_g - temp_b;

			}

			else if (GREEN == colorMode) //green color

			{

				temp = temp_g * 2 - temp_r - temp_b;

			}

			else if (BLUE == colorMode) //blue color

			{

				temp = temp_b * 2 - temp_r - temp_g;

			}



			if (temp <= thresholdValue)

			{

				temp = 0;

			}

			else if (temp > thresholdValue)

			{

				temp = 255;

			}



			dst.at<uchar>(i, j) = temp;







		}



}



void CircleFinder::segmentProcess2(Mat &src, Mat &dst) //segment base on HSV model

{

	Mat imgHSV;

	int hValueMin, hValueMax, sValueMin, sValueMax, vValueMin, vValueMax;



	switch (colorMode)

	{

	case RED:

		hValueMin = 156;

		hValueMax = 180;

		sValueMin = 43;

		sValueMax = 255;

		vValueMin = 46;

		vValueMax = 255;

		break;

	case GREEN:

		hValueMin = 35;

		hValueMax = 77;

		sValueMin = 43;

		sValueMax = 255;

		vValueMin = 30;//46;

		vValueMax = 180;//255

		break;

	case BLUE:

		hValueMin = 91;

		hValueMax = 130;

		sValueMin = 43;

		sValueMax = 255;

		vValueMin = 46;

		vValueMax = 255;

		break;

	default:

		hValueMin = 35;

		hValueMax = 77;

		sValueMin = 43;

		sValueMax = 255;

		vValueMin = 30;//46;

		vValueMax = 255;

		break;

	}



	cvtColor(src, imgHSV, CV_BGR2HSV);

	if (RED == colorMode)

	{

		Mat dst1, dst2;

		inRange(imgHSV, Scalar(hValueMin, sValueMin, vValueMin), Scalar(hValueMax, sValueMax, vValueMax), dst1);

		inRange(imgHSV, Scalar(0, sValueMin, vValueMin), Scalar(15, sValueMax, vValueMax), dst2);

		dst = dst1 + dst2;

	}

	else

	{

		inRange(imgHSV, Scalar(hValueMin, sValueMin, vValueMin), Scalar(hValueMax, sValueMax, vValueMax), dst);

	}

}







bool ellipsefinder(Mat src, vector<Point> contour, RotatedRect ellipse, double ratio = 0.01)

{

	//µÃµ½ÍÖÔ²ÉÏËùÓÐµÄµã

	vector<Point> ellipse_point;



	//µÃµ½ÍÖÔ²µÄ²ÎÊý

	Point2f center = ellipse.center;

	double a_2 = pow(ellipse.size.width * 0.5, 2);

	double b_2 = pow(ellipse.size.height * 0.5, 2);

	double ellipse_angle = (ellipse.angle * 3.1415926) / 180;





	//ÉÏ²¿

	for (int i = 0; i < ellipse.size.width; i++)

	{

		double x = -ellipse.size.width * 0.5 + i;

		double y_left = sqrt((1 - (x * x / a_2)) * b_2);



		//rotate

		//[ cos(seta) sin(seta)]

		//[-sin(seta) cos(seta)]

		cv::Point2f rotate_point_left;

		rotate_point_left.x = cos(ellipse_angle) * x - sin(ellipse_angle) * y_left;

		rotate_point_left.y = +sin(ellipse_angle) * x + cos(ellipse_angle) * y_left;



		//trans

		rotate_point_left += center;



		//store

		ellipse_point.push_back(Point(rotate_point_left));

	}

	//ÏÂ²¿

	for (int i = 0; i < ellipse.size.width; i++)

	{

		double x = ellipse.size.width * 0.5 - i;

		double y_right = -sqrt((1 - (x * x / a_2)) * b_2);



		//rotate

		//[ cos(seta) sin(seta)]

		//[-sin(seta) cos(seta)]

		cv::Point2f rotate_point_right;

		rotate_point_right.x = cos(ellipse_angle) * x - sin(ellipse_angle) * y_right;

		rotate_point_right.y = +sin(ellipse_angle) * x + cos(ellipse_angle) * y_right;



		//trans

		rotate_point_right += center;



		//´æ´¢

		ellipse_point.push_back(Point(rotate_point_right));



	}





	vector<vector<Point> > contours1;

	contours1.push_back(ellipse_point);

	//drawContours(src,contours1,-1,Scalar(255,0,0),2);



	//match shape

	double a0 = matchShapes(ellipse_point, contour, CV_CONTOURS_MATCH_I1, 0);

	if (a0 > 0.01)

	{

		return true;

	}



	return false;

}









int CircleFinder::circleCalculate(Mat &src) //´Ó·Ö¸îÍ¼ÏñÖÐ¼ì²âÂú×ãÌõ¼þµÄ×î´óµÄÔ²£¬¸³Öµ¸øÀàÀïµÄÔ²ÐÄºÍ°ë¾¶³ÉÔ±±äÁ¿£¬²¢ÔÚÍ¼ÏñÖÐ»­³ö

{

	//src is binary image,later modified as BGR
	int low_H = 35, low_S = 43, low_V = 46;
	int High_H = 77, High_S = 255, High_V = 255;
	Mat hsv, bin, imgBlur;

	//imshow("原图", src);

	cvtColor(src, hsv, CV_BGR2HSV);  //this is the problem	
	inRange(hsv, Scalar(low_H, low_S, low_V), Scalar(High_H, High_S, High_V), bin);

	GaussianBlur(bin, imgBlur, Size(5, 3), 2, 2);

	vector<vector<Point>> contours;

	double max_area, min_area, curr_area = 0, last_area = 0;
	int chosen_idx = -1;

	max_area = maxRadius * maxRadius*PI;

	min_area = minRadius * minRadius*PI;

	//使用canny检测出边缘

	Mat edge_image;
	imshow("Blur",imgBlur);
	
	Canny(imgBlur, edge_image, 30, 70);

	//边缘追踪，没有存储边缘的组织结构

	findContours(edge_image, contours, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE);

	//Mat cimage = Mat::zeros(edge_image.size(), CV_8UC3);
	for (size_t i = 0; i < contours.size(); i++)

	{

		//拟合的点至少为6

		size_t count = contours[i].size();

		if (count < 6)

			continue;



		//椭圆拟合

		RotatedRect box = fitEllipse(contours[i]);



		//如果长宽比大于30，则排除，不做拟合

		if (MAX(box.size.width, box.size.height) > MIN(box.size.width, box.size.height) * 30)

			continue;

		curr_area = contourArea(contours[i]);

		

		if (curr_area > min_area && curr_area < max_area) {

			if (curr_area > last_area) {
				chosen_idx = i;
				last_area = curr_area;
			}
		}
	}

	imshow("canny边缘", edge_image);

	if (chosen_idx == -1) {

		return -1;

	}

	else {

		// mark result found
		//画出追踪出的轮廓，bug
		//drawContours(cimage, contours[chosen_idx], chosen_idx, Scalar::all(255), 1, 8);
		//drawContours(src, contours, chosen_idx, Scalar::all(255));
		float r;

		Point2f center;

		minEnclosingCircle(Mat(contours[chosen_idx]), center, r);

		circle(src, Point(center), static_cast<int>(r), Scalar(255), 2);



		circleCenter.x = cvRound(center.x);				

		circleCenter.y = cvRound(center.y);

		radius = cvRound(r);

		//画出拟合的椭圆，还需选择box的id

		//ellipse(cimage, box, Scalar(0, 0, 255), 1, CV_AA);
		
		
		cout<<endl<<endl<<endl;
		cout<<"circle found"<<endl;
		cout<<"radius: "<<radius<<endl;
		
		cout<<endl<<endl<<endl;

	}

	//imshow("拟合结果", src);

	//waitKey();

	return 0;

}



int CircleFinder::circleCalculate2(Mat &src)

{

	radius = 0;





	vector<vector<Point>> contours;

	vector<Vec4i> hierarchy;

	findContours(src, contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE);



	float areaContour = 0;

	Point2f centerDetect;

	float radiusDetect;

	Point2f centerDetectMax;

	float radiusDetectMax = 0;



	for (int i = 0; i < contours.size(); i++)

	{

		areaContour = contourArea(contours[i]);

		minEnclosingCircle(contours[i], centerDetect, radiusDetect);

		if (areaContour >= 0.95*PI*radiusDetect*radiusDetect && radiusDetect >= minRadius && radiusDetect <= maxRadius)

		{

			if (radiusDetect > radiusDetectMax)

			{

				radiusDetectMax = radiusDetect;

				centerDetectMax.x = centerDetect.x;

				centerDetectMax.y = centerDetect.y;

			}

		}



	}

	if (radiusDetectMax > 0)

	{

		radius = cvRound(radiusDetectMax);

		circleCenter.x = cvRound(centerDetectMax.x);

		circleCenter.y = cvRound(centerDetectMax.y);

		circle(src, circleCenter, radius, Scalar(255, 255, 0), 3, 8, 0);

		return 0;

	}

	else

	{

		cout << "No match circle find!!!" << endl;

		return -1;

	}



}







double CircleFinder::circleDistance(Mat &src) //¼ì²âÔ²µÄÔ²ÐÄµ½Í¼ÏñÖÐÐÄµÄ¾àÀë + °ë¾¶

{

	double distance = 0;

	double distance_x = circleCenter.x - src.cols;

	double distance_y = circleCenter.y - src.rows;

	// distance=sqrt(distance_x*distance_x+distance_y*distance_y);



	return distance;

}

/////////////////////////////////////////////////////////////





///////////////////////////////////////////////////////////ConfigFileRead

ConfigFileRead::ConfigFileRead() {}

int ConfigFileRead::readConfigFile(string filePath)//¶ÁÈ¡±¾µØ²ÎÊýÅäÖÃÎÄ¼þ

{

	configFile.open(filePath.c_str());

	if (configFile.is_open())

	{

		cout << "read config file successed!!!" << endl;

		return 0;

	}

	else

	{

		cout << "read config file failed!!!" << endl;

		return -1;

	}



}



string ConfigFileRead::readValue(string keyWords)//¶ÁÈ¡±¾µØ²ÎÊýÅäÖÃÎÄ¼þÖÐÏàÓ¦KeyWordsµÄÖµ

{

	if (!configFile.is_open())

	{

		return{};

	}

	streampos pos = configFile.tellg();

	string strLine;

	string value;

	while (!configFile.eof())

	{

		getline(configFile, strLine);



		if ('#' == strLine[0])

		{

			continue;

		}



		size_t pose = strLine.find('=');

		string key = strLine.substr(0, pose);



		if (key == keyWords)

		{

			value = strLine.substr(pose + 1);

			configFile.seekg(pos);

			return value;

		}



	}

	configFile.seekg(pos);

	return{};

}



int ConfigFileRead::closeConfigFile()//¹Ø±Õ±¾µØÅäÖÃÎÄ¼þ

{

	configFile.close();

	if (configFile.is_open())

		return -1;

	return 0;

}



